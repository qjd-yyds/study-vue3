{"version":3,"file":"reativity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reative.ts"],"sourcesContent":["// 判断是否对象\nexport const isObject = (val: unknown): val is Record<any, any> => val !== null && typeof val === 'object';\n// 合并对象\nexport const extend = Object.assign;\n\nexport const isArray = Array.isArray;\n\nexport const isFunction = (val) => typeof val === 'function';\n\nexport const isString = (val) => typeof val === 'string';\nexport const isNumber = (val) => typeof val === 'number';\n\n// 判断是否存在属性\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport const hasOwn = (val: object, key: string | symbol): key is keyof typeof val => hasOwnProperty.call(val, key);\n\n// 判断数组的key是不是整数\nexport const isIntegerKey = (key) => isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;\n","export function effect(fn, options: any = {}) {\n  const effect = createReactiveEffect(fn, options);\n  // 判断options\n  if (!options.lazy) {\n    console.log('用户没有传递lazy，执行');\n    effect(); // 默认执行\n  }\n  return effect;\n}\nlet uid = 0; // 记录effect的下标\nlet activeEffect; // 保存当前的effect\nconst effectTrack = []; // 定义一个栈解决嵌套树型结构effect，为了解决当前effect是哪一个\n/*\n[effect1,effect2,effect3]]\neffect(() => {\n  state.name\n  effect(() => {\n    state.age\n    effect(() => {\n      state.a\n    })\n  })\n\n})\n*/\nfunction createReactiveEffect(fn, options) {\n  const effect = function reativeEffect() {\n    if (!effectTrack.includes(effect)) {\n      console.log('当前创建的effect不存在栈中,创建effect');\n      // 没有入栈当前的effect\n      try {\n        // 入栈\n        effectTrack.push(effect);\n        activeEffect = effect;\n        console.log('执行用户方法');\n        // 响应式effect\n        fn(); // 执行用户的方法\n      } finally {\n        console.log('执行finally');\n        // 无论是否成功，都执行\n        // 出栈\n        effectTrack.pop();\n        activeEffect = effectTrack[effectTrack.length - 1];\n      }\n    }\n  };\n  effect.id = uid++; // 区别effect\n  effect._isEffect = true; // 区分是否响应\n  effect.raw = fn; // 保存用户方法\n  effect.options = options; // 保存用户配置\n  return effect;\n}\n\n// 收集effect，获取数据的时候触发get 收集effect\nlet targetMap = new WeakMap(); // 创建表\nexport function Track(target, type, key) {\n  console.log('触发get，且当前不是只读，进行收集依赖');\n  console.log(target, type, key, activeEffect, activeEffect.id);\n  // 1.name ==> effect\n  // key和effect一一对应\n  if (typeof activeEffect === 'undefined') {\n    // 当前对象没有的在effect函数中使用\n    return;\n  }\n  // key===target==属性==>Set[effect,effect]\n  let depMap = targetMap.get(target); //\n  if (!depMap) {\n    targetMap.set(target, (depMap = new Map())); // 添加值\n  }\n  // 当前key\n  let dep = depMap.get(key);\n  // 判断key是否存在，不存在就创建一个set\n  if (!dep) {\n    depMap.set(key, (dep = new Set()));\n  }\n  // 如果当前set不存在当前effect，\n  if (!dep.has(activeEffect)) {\n    // 收集effect，并添加进去\n    dep.add(activeEffect);\n  }\n  console.log('依赖收集完成，当前创建的依赖weakmap==>', targetMap);\n}\n","import { hasOwn, isArray, isIntegerKey, isObject } from '@vue/shared';\nimport { Track } from './effect';\nimport { TrackOpTypes } from './operations';\nimport { readonly, reative } from './reative';\n// 处理get\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    const res = Reflect.get(target, key, receiver); // target[key]\n    // 不是只读\n    if (!isReadonly) {\n      // 收集依赖effect,目标对象的key采用的操作get\n      Track(target, TrackOpTypes.GET, key);\n    }\n    // 浅\n    if (shallow) {\n      return res;\n    }\n    // key是一个对象,递归，懒代理，即当访问下一层对象才开始进行拦截，必须被使用\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reative(res);\n    }\n    return res;\n  };\n}\n\n// 柯里化，根据不同参数处理逻辑\n// 处理get\nconst get = /*#__PURE__*/ createGetter(); // 深度非只读\nconst shallowGet = /*#__PURE__*/ createGetter(false, true); // 非只读 浅\nconst readonlyGet = /*#__PURE__*/ createGetter(true); // 只读 深度\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true); // 只读 浅\n\n// 处理set,是否浅\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    const result = Reflect.set(target, key, value, receiver);\n    // 设置的是数组还是对象，添加值还是修改\n    // 获取老值\n    const oldValue = target[key];\n    // 判断是否是数组，proxy的key就是数组的索引，如果key大于length表示新增false,小于表示修改true\n    // 如果是对象，如果存在属性就是修改true，不存在就是新增属性flase\n    let haskey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    if(!haskey) {// 没有\n      // 新增\n    }else {\n      // 修改\n      // trigger(target)\n    }\n    return result;\n  };\n}\nconst set = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\n// 全部代理\nexport const reativeHandlers = {\n  get,\n  set\n};\n// 数据第一层代理\nexport const shallowReactiveHandlers = {\n  get: shallowGet,\n  set: shallowSet\n};\n// 全部只读\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set: (target, key, value) => {\n    console.error('不可以修改key，只读全部');\n  }\n};\n// 第一层只读\nexport const shallowReativeHandlers = {\n  get: shallowReadonlyGet,\n  set: (target, key, value) => {\n    console.error('不可以修改key只读一层');\n  }\n};\n","import { isObject } from '@vue/shared';\nimport { reativeHandlers, shallowReactiveHandlers, readonlyHandlers, shallowReativeHandlers } from './baseHandlers';\nexport function reative(target) {\n  return createReativeObj(target, false, reativeHandlers);\n}\nexport function shallowReactive(target) {\n  return createReativeObj(target, false, shallowReactiveHandlers);\n}\nexport function readonly(target) {\n  return createReativeObj(target, true, readonlyHandlers);\n}\nexport function shallowReative(target) {\n  return createReativeObj(target, true, shallowReativeHandlers);\n}\n\n// 核心是proxy 采用柯里化根据不同参数处理\n// 创建一个表来存储当前代理的对象\nconst reativeMap = new WeakMap(); // key必须为一个对象 自动垃圾回收\nconst readOnlyMap = new WeakMap(); // key必须为一个对象 自动垃圾回收\n// 创建reative对象，返回一个proxy\nfunction createReativeObj(target, isReadonly, baseHandlers) {\n  if (!isObject(target)) {\n    console.error(\"必须为一个对象\")\n    return target;\n  }\n  console.log('reative传入的值=>', target);\n  // 通过是否只读来创建不同map\n  const proxyMap = isReadonly ? readOnlyMap : reativeMap;\n  const proxyEs = proxyMap.get(target);\n  // 如果已经创建过，就返回已经创建的代理\n  if (proxyEs) {\n    return proxyEs;\n  }\n  // 如果没有，将代理存入表中，并返回\n  const proxy = new Proxy(target, baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n"],"names":[],"mappings":";;;EAAA;EACO,MAAM,QAAQ,GAAG,CAAC,GAAY,KAA8B,GAAG,KAAK,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC;EAIpG,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;EAI9B,MAAM,QAAQ,GAAG,CAAC,GAAG,KAAK,OAAO,GAAG,KAAK,QAAQ,CAAC;EAGzD;EACA,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC;EAChD,MAAM,MAAM,GAAG,CAAC,GAAW,EAAE,GAAoB,KAA8B,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;EAEpH;EACO,MAAM,YAAY,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAC,GAAG,CAAC,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,EAAE,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,KAAK,GAAG;;WCjBvG,MAAM,CAAC,EAAE,EAAE,UAAe,EAAE;MAC1C,MAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;;MAEjD,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;UACjB,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;UAC7B,MAAM,EAAE,CAAC;OACV;MACD,OAAO,MAAM,CAAC;EAChB,CAAC;EACD,IAAI,GAAG,GAAG,CAAC,CAAC;EACZ,IAAI,YAAY,CAAC;EACjB,MAAM,WAAW,GAAG,EAAE,CAAC;EACvB;;;;;;;;;;;;;EAaA,SAAS,oBAAoB,CAAC,EAAE,EAAE,OAAO;MACvC,MAAM,MAAM,GAAG,SAAS,aAAa;UACnC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;cACjC,OAAO,CAAC,GAAG,CAAC,2BAA2B,CAAC,CAAC;;cAEzC,IAAI;;kBAEF,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;kBACzB,YAAY,GAAG,MAAM,CAAC;kBACtB,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;;kBAEtB,EAAE,EAAE,CAAC;eACN;sBAAS;kBACR,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;;;kBAGzB,WAAW,CAAC,GAAG,EAAE,CAAC;kBAClB,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;eACpD;WACF;OACF,CAAC;MACF,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE,CAAC;MAClB,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC;MACxB,MAAM,CAAC,GAAG,GAAG,EAAE,CAAC;MAChB,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;MACzB,OAAO,MAAM,CAAC;EAChB,CAAC;EAED;EACA,IAAI,SAAS,GAAG,IAAI,OAAO,EAAE,CAAC;WACd,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG;MACrC,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;MACpC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,YAAY,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC;;;MAG9D,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE;;UAEvC,OAAO;OACR;;MAED,IAAI,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;MACnC,IAAI,CAAC,MAAM,EAAE;UACX,SAAS,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,EAAE,EAAE,CAAC;OAC7C;;MAED,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;MAE1B,IAAI,CAAC,GAAG,EAAE;UACR,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,EAAE,CAAC;OACpC;;MAED,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;;UAE1B,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;OACvB;MACD,OAAO,CAAC,GAAG,CAAC,0BAA0B,EAAE,SAAS,CAAC,CAAC;EACrD;;EC7EA;EACA,SAAS,YAAY,CAAC,UAAU,GAAG,KAAK,EAAE,OAAO,GAAG,KAAK;MACvD,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ;UACvC,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;;UAE/C,IAAI,CAAC,UAAU,EAAE;;cAEf,KAAK,CAAC,MAAM,mBAAoB,GAAG,CAAC,CAAC;WACtC;;UAED,IAAI,OAAO,EAAE;cACX,OAAO,GAAG,CAAC;WACZ;;UAED,IAAI,QAAQ,CAAC,GAAG,CAAC,EAAE;cACjB,OAAO,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;WAClD;UACD,OAAO,GAAG,CAAC;OACZ,CAAC;EACJ,CAAC;EAED;EACA;EACA,MAAM,GAAG,iBAAiB,YAAY,EAAE,CAAC;EACzC,MAAM,UAAU,iBAAiB,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;EAC3D,MAAM,WAAW,iBAAiB,YAAY,CAAC,IAAI,CAAC,CAAC;EACrD,MAAM,kBAAkB,iBAAiB,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;EAElE;EACA,SAAS,YAAY,CAAC,OAAO,GAAG,KAAK;MACnC,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;UAC9C,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;;;UAGxC,MAAM,CAAC,GAAG,EAAE;;;UAGhB,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE;UAOtG,OAAO,MAAM,CAAC;OACf,CAAC;EACJ,CAAC;EACD,MAAM,GAAG,iBAAiB,YAAY,EAAE,CAAC;EACzC,MAAM,UAAU,iBAAiB,YAAY,CAAC,IAAI,CAAC,CAAC;EACpD;EACO,MAAM,eAAe,GAAG;MAC7B,GAAG;MACH,GAAG;GACJ,CAAC;EACF;EACO,MAAM,uBAAuB,GAAG;MACrC,GAAG,EAAE,UAAU;MACf,GAAG,EAAE,UAAU;GAChB,CAAC;EACF;EACO,MAAM,gBAAgB,GAAG;MAC9B,GAAG,EAAE,WAAW;MAChB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK;UACtB,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;OAChC;GACF,CAAC;EACF;EACO,MAAM,sBAAsB,GAAG;MACpC,GAAG,EAAE,kBAAkB;MACvB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK;UACtB,OAAO,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;OAC/B;GACF;;WC1Ee,OAAO,CAAC,MAAM;MAC5B,OAAO,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;EAC1D,CAAC;WACe,eAAe,CAAC,MAAM;MACpC,OAAO,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;EAClE,CAAC;WACe,QAAQ,CAAC,MAAM;MAC7B,OAAO,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,gBAAgB,CAAC,CAAC;EAC1D,CAAC;WACe,cAAc,CAAC,MAAM;MACnC,OAAO,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,sBAAsB,CAAC,CAAC;EAChE,CAAC;EAED;EACA;EACA,MAAM,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;EACjC,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;EAClC;EACA,SAAS,gBAAgB,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY;MACxD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;UACrB,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA;UACxB,OAAO,MAAM,CAAC;OACf;MACD,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;;MAErC,MAAM,QAAQ,GAAG,UAAU,GAAG,WAAW,GAAG,UAAU,CAAC;MACvD,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;;MAErC,IAAI,OAAO,EAAE;UACX,OAAO,OAAO,CAAC;OAChB;;MAED,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;MAC9C,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;MAC5B,OAAO,KAAK,CAAC;EACf;;;;;;;;;;;;;;;;"}