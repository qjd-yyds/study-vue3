{"version":3,"file":"reativity.cjs.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reative.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["// 判断是否对象\nexport const isObject = (val: unknown): val is Record<any, any> => val !== null && typeof val === 'object';\n// 合并对象\nexport const extend = Object.assign;\n\nexport const isArray = Array.isArray;\n\nexport const isFunction = (val) => typeof val === 'function';\n\nexport const isString = (val) => typeof val === 'string';\nexport const isNumber = (val) => typeof val === 'number';\n\n// 判断是否存在属性\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nexport const hasOwn = (val: object, key: string | symbol): key is keyof typeof val => hasOwnProperty.call(val, key);\n\n// 判断数组的key是不是整数\nexport const isIntegerKey = (key) => isString(key) && key !== 'NaN' && key[0] !== '-' && '' + parseInt(key, 10) === key;\n\n// 判断两个值是否相同\nexport const hasChanged = (value: any, oldValue: any): boolean => !Object.is(value, oldValue);\n\nexport * from './shapeFlags';\n","import { isArray, isIntegerKey } from '@vue/shared';\nimport { TriggerOpTypes } from './operations';\n\nexport function effect(fn, options: any = {}) {\n  const effect = createReactiveEffect(fn, options);\n  // 判断options\n  if (!options.lazy) {\n    console.log('用户没有传递lazy，立即执行一次');\n    effect(); // 默认执行\n  }\n  return effect;\n}\nlet uid = 0; // 记录effect的下标\nlet activeEffect; // 保存当前的effect\nconst effectTrack = []; // 定义一个栈解决嵌套树型结构effect，为了解决当前effect是哪一个\n/*\n[effect1,effect2,effect3]]\neffect(() => {\n  state.name\n  effect(() => {\n    state.age\n    effect(() => {\n      state.a\n    })\n  })\n\n})\n*/\nfunction createReactiveEffect(fn, options) {\n  const effect = function reativeEffect() {\n    if (!effectTrack.includes(effect)) {\n      // 当前创建的effect不存在栈中,创建effect\n      // 没有入栈当前的effect\n      try {\n        // 入栈\n        effectTrack.push(effect);\n        activeEffect = effect;\n        // 响应式effect\n        return fn(); // 执行用户的方法\n      } finally {\n        // 无论是否成功，都执行\n        // 出栈\n        effectTrack.pop();\n        activeEffect = effectTrack[effectTrack.length - 1];\n      }\n    }\n  };\n  effect.id = uid++; // 区别effect\n  effect._isEffect = true; // 区分是否响应\n  effect.raw = fn; // 保存用户方法\n  effect.options = options; // 保存用户配置\n  return effect;\n}\n\n// 收集effect，获取数据的时候触发get 收集effect\nlet targetMap = new WeakMap(); // 创建表\nexport function Track(target, type, key) {\n  console.log('触发收集', '被收集的target==>', target, '被收集的key==>', key);\n  // 1.name ==> effect\n  // key和effect一一对应\n  if (typeof activeEffect === 'undefined') {\n    // 当前对象没有的在effect函数中使用\n    return;\n  }\n  // key===target==属性==>Set[effect,effect]\n  let depMap = targetMap.get(target); //\n  if (!depMap) {\n    targetMap.set(target, (depMap = new Map())); // 添加值\n  }\n  // 当前key\n  let dep = depMap.get(key);\n  // 判断key是否存在，不存在就创建一个set\n  if (!dep) {\n    depMap.set(key, (dep = new Set()));\n  }\n  // 如果当前set不存在当前effect，\n  if (!dep.has(activeEffect)) {\n    // 收集effect，并添加进去\n    dep.add(activeEffect);\n  }\n  console.log('依赖收集完成，当前创建的依赖weakmap==>', targetMap);\n}\n\n// 触发依赖\n// 1.处理对象\nexport function trigger(target, type, key?, newValue?, oldValue?) {\n  // 触发更新\n  const depsMap = targetMap.get(target);\n  // 判断目标对象有没有被收集==> 不是响应的\n  if (!depsMap) return;\n  const effectSet = new Set();\n  // 性能优化如果有多个同时修改一个值，相同就过滤\n  const add = (effectAdd) => {\n    if (effectAdd) {\n      effectAdd.forEach((effect) => {\n        effectSet.add(effect);\n      });\n    }\n  };\n  // 修改数组长度，数组特殊处理\n  if (key === 'length' && isArray(target)) {\n    // proxy在添加数组的时候默认会讲length等属性加入\n    // 在effect中length也被添加依赖\n    // 当用户修改长度，或者修改的下标小于所有数组的下标\n    // 将length和下标的effect放入dep中\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newValue) {\n        add(dep);\n      }\n    });\n  } else {\n    // 可能是对象\n    if (key !== undefined) {\n      // 获取当前key下的effect\n      add(depsMap.get(key));\n    }\n    switch (type) {\n      // 如果是新增属性\n      case TriggerOpTypes.ADD:\n        if (isArray(target) && isIntegerKey(key)) {\n          // 如果是个数组且key为整数，就将length的effect加入依赖\n          add(depsMap.get('length'));\n        }\n    }\n  }\n  // 触发effect方法\n  effectSet.forEach((effect: any) => {\n    if (effect.options.scheduler) {\n      // 当前scheduler存在，effect为computed,effect的副作用放在get里\n      effect.options.scheduler();\n    } else {\n      effect();\n    }\n  });\n  // 执行\n}\n","import { hasChanged, hasOwn, isArray, isIntegerKey, isObject } from '@vue/shared';\nimport { Track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOpTypes } from './operations';\nimport { readonly, reative } from './reative';\n// 处理get\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    const res = Reflect.get(target, key, receiver); // target[key]\n    // 不是只读\n    if (!isReadonly) {\n      // 收集依赖effect,目标对象的key采用的操作get\n      Track(target, TrackOpTypes.GET, key);\n    }\n    // 浅\n    if (shallow) {\n      return res;\n    }\n    // key是一个对象,递归，懒代理，即当访问下一层对象才开始进行拦截，必须被使用\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reative(res);\n    }\n    return res;\n  };\n}\n\n// 柯里化，根据不同参数处理逻辑\n// 处理get\nconst get = /*#__PURE__*/ createGetter(); // 深度非只读\nconst shallowGet = /*#__PURE__*/ createGetter(false, true); // 非只读 浅\nconst readonlyGet = /*#__PURE__*/ createGetter(true); // 只读 深度\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true); // 只读 浅\n\n// 处理set,是否浅\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    // 存储旧值\n    const oldValue = target[key];\n    // 设置的是数组还是对象，添加值还是修改\n    // 判断是否是数组，proxy的key就是数组的索引，如果key大于length表示新增false,小于表示修改true\n    // 如果是对象，如果存在属性就是修改true，不存在就是新增属性flase\n    let hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n\n    const result = Reflect.set(target, key, value, receiver);\n    if (!hadKey) {\n      // 没有，触发新增数据\n      console.log('当前值为新增，触发set新增==>', key);\n      // 新增 key操作的属性 value 新值\n      trigger(target, TriggerOpTypes.ADD, key, value);\n    } else {\n      // 有，修改值\n      // 如果新值和旧值不相同\n      if (hasChanged(value, oldValue)) {\n        console.log('当前值为修改，触发set修改');\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nconst set = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\n// 全部代理\nexport const reativeHandlers = {\n  get,\n  set\n};\n// 数据第一层代理\nexport const shallowReactiveHandlers = {\n  get: shallowGet,\n  set: shallowSet\n};\n// 全部只读\nexport const readonlyHandlers = {\n  get: readonlyGet,\n  set: (target, key, value) => {\n    console.error('不可以修改key，只读全部');\n  }\n};\n// 第一层只读\nexport const shallowReativeHandlers = {\n  get: shallowReadonlyGet,\n  set: (target, key, value) => {\n    console.error('不可以修改key只读一层');\n  }\n};\n","import { isObject } from '@vue/shared';\nimport { reativeHandlers, shallowReactiveHandlers, readonlyHandlers, shallowReativeHandlers } from './baseHandlers';\nexport function reative(target) {\n  return createReativeObj(target, false, reativeHandlers);\n}\nexport function shallowReactive(target) {\n  return createReativeObj(target, false, shallowReactiveHandlers);\n}\nexport function readonly(target) {\n  return createReativeObj(target, true, readonlyHandlers);\n}\nexport function shallowReative(target) {\n  return createReativeObj(target, true, shallowReativeHandlers);\n}\n\n// 核心是proxy 采用柯里化根据不同参数处理\n// 创建一个表来存储当前代理的对象\nconst reativeMap = new WeakMap(); // key必须为一个对象 自动垃圾回收\nconst readOnlyMap = new WeakMap(); // key必须为一个对象 自动垃圾回收\n// 创建reative对象，返回一个proxy\nfunction createReativeObj(target, isReadonly, baseHandlers) {\n  if (!isObject(target)) {\n    console.error(\"必须为一个对象\")\n    return target;\n  }\n  console.log('reative传入的值=>', target);\n  // 通过是否只读来创建不同map\n  const proxyMap = isReadonly ? readOnlyMap : reativeMap;\n  const proxyEs = proxyMap.get(target);\n  // 如果已经创建过，就返回已经创建的代理\n  if (proxyEs) {\n    return proxyEs;\n  }\n  // 如果没有，将代理存入表中，并返回\n  const proxy = new Proxy(target, baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n","import { hasChanged, isArray } from '@vue/shared';\nimport { Track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOpTypes } from './operations';\n\nexport function ref(target) {\n  return createRef(target);\n}\nexport function shallowRef(target) {\n  // 浅，如果是一个对象\n  return createRef(target, true);\n}\n// 创建类RefImpl\nclass RefImpl {\n  public __v_isRef = true; // 标识ref代理\n  public _value;\n  constructor(public rawValue, public shallow) {\n    this._value = rawValue; // 原来的值\n  }\n  // 类的属性访问器,收集依赖track\n  get value() {\n    Track(this, TrackOpTypes.GET, 'value');\n    return this._value;\n  }\n  set value(newValue) {\n    // 修改，触发依赖\n    if (hasChanged(newValue, this._value)) {\n      this._value = newValue;\n      this.rawValue = newValue;\n      console.log('触发set--value');\n      trigger(this, TriggerOpTypes.SET, 'value', newValue);\n    }\n  }\n}\n/**\n * @description: 创建ref，返回实例对象\n * @param {*} rawValue\n * @param {Boolean} shallow\n * @return {Object} RefImpl\n */\nfunction createRef(rawValue, shallow = false) {\n  // 创建ref，返回实例对象\n  return new RefImpl(rawValue, shallow);\n}\n/**\n * @description: 目标对象如果是响应式，返回的属性是响应的，如果是普通的就是普通的\n * @param {Object} target\n * @param {String} key\n * @return {ObjectRefImpl} ObjectRefImpl\n */\nexport function toRef(target, key) {\n  return new ObjectRefImpl(target, key);\n}\n/**\n * @description: toref返回的值，本质是通过模拟value 触发reative的get和set\n * @param {Object} target\n * @param {String} key\n */\nclass ObjectRefImpl {\n  public __v_isRef = true; // 标识ref代理\n  constructor(public target, public key) {}\n  get value() {\n    return this.target[this.key];\n  }\n  set value(newValue) {\n    this.target[this.key] = newValue;\n  }\n}\n/**\n * @description: reative的所有值变成ObjectRefImpl实例\n * @param {object} reative\n * @return {object} Record<string,ObjectRefImpl>\n */\nexport function toRefs(target) {\n  // 遍历当前对象\n  // 如果是数组 new Array\n  let ret = isArray(target) ? new Array(target.length) : {};\n  for (let key in target) {\n    // 将对象变成toref\n    ret[key] = toRef(target, key);\n  }\n  return ret;\n}\n","import { isFunction } from '@vue/shared';\nimport { effect } from '.';\n\n// 计算属性\nexport function computed(getterOrOptions) {\n  // 1.函数 2.对象\n  // 获取数据\n  let getter; // 获取\n  let setter; // 设置\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n    setter = () => {\n      console.warn('computed value must be readonly');\n    };\n  } else {\n    // {get(),set()}\n    // 对象\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  return new ComputedRefImpl(getter, setter);\n}\n\nclass ComputedRefImpl {\n  public _dirty = true; // 默认获取执行\n  public _value;\n  public effect;\n  constructor(getter, public setter) {\n    // 当创建一个computed的时候，就当前的getter作为effect的回调函数\n    // 并且将effect存到自己的effect\n    this.effect = effect(getter, {\n      lazy: true,\n      scheduler: () => {\n        // 当修改数据的时候执行\n        if (!this._dirty) {\n          this._dirty = true;\n        }\n      }\n    });\n  }\n  // 通过.value\n  get value() {\n    // 当获取xxx.value的时候，执行effect函数，吧effect执行后的数据放在_value,并返回这个数据\n    // 如果当前dirty为false，代表当前依赖响应未发生变化，从缓存拿值\n    if (this._dirty) {\n      console.log('进入缓存判断，当前dirty为true，执行effect');\n      this._dirty = false; // 变更为false\n      this._value = this.effect(); // 获取用户的值，只要数据被改变\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    this.setter(newValue);\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACO,MAAM,QAAQ,GAAG,CAAC,GAAY,KAA8B,GAAG,KAAK,IAAI,IAAI,OAAO,GAAG,KAAK,QAAQ,CAAC;AAIpG,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;AAE9B,MAAM,UAAU,GAAG,CAAC,GAAG,KAAK,OAAO,GAAG,KAAK,UAAU,CAAC;AAEtD,MAAM,QAAQ,GAAG,CAAC,GAAG,KAAK,OAAO,GAAG,KAAK,QAAQ,CAAC;AAGzD;AACA,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC;AAChD,MAAM,MAAM,GAAG,CAAC,GAAW,EAAE,GAAoB,KAA8B,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAEpH;AACO,MAAM,YAAY,GAAG,CAAC,GAAG,KAAK,QAAQ,CAAC,GAAG,CAAC,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,EAAE,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,KAAK,GAAG,CAAC;AAExH;AACO,MAAM,UAAU,GAAG,CAAC,KAAU,EAAE,QAAa,KAAc,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC;;SCjB7E,MAAM,CAAC,EAAE,EAAE,UAAe,EAAE;IAC1C,MAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;;IAEjD,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;QACjB,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAC;QACjC,MAAM,EAAE,CAAC;KACV;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AACD,IAAI,GAAG,GAAG,CAAC,CAAC;AACZ,IAAI,YAAY,CAAC;AACjB,MAAM,WAAW,GAAG,EAAE,CAAC;AACvB;;;;;;;;;;;;;AAaA,SAAS,oBAAoB,CAAC,EAAE,EAAE,OAAO;IACvC,MAAM,MAAM,GAAG,SAAS,aAAa;QACnC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;;;YAGjC,IAAI;;gBAEF,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBACzB,YAAY,GAAG,MAAM,CAAC;;gBAEtB,OAAO,EAAE,EAAE,CAAC;aACb;oBAAS;;;gBAGR,WAAW,CAAC,GAAG,EAAE,CAAC;gBAClB,YAAY,GAAG,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;aACpD;SACF;KACF,CAAC;IACF,MAAM,CAAC,EAAE,GAAG,GAAG,EAAE,CAAC;IAClB,MAAM,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,MAAM,CAAC,GAAG,GAAG,EAAE,CAAC;IAChB,MAAM,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;AACA,IAAI,SAAS,GAAG,IAAI,OAAO,EAAE,CAAC;SACd,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,GAAG;IACrC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,eAAe,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG,CAAC,CAAC;;;IAGhE,IAAI,OAAO,YAAY,KAAK,WAAW,EAAE;;QAEvC,OAAO;KACR;;IAED,IAAI,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACnC,IAAI,CAAC,MAAM,EAAE;QACX,SAAS,CAAC,GAAG,CAAC,MAAM,GAAG,MAAM,GAAG,IAAI,GAAG,EAAE,EAAE,CAAC;KAC7C;;IAED,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;IAE1B,IAAI,CAAC,GAAG,EAAE;QACR,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,EAAE,EAAE,CAAC;KACpC;;IAED,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;;QAE1B,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;KACvB;IACD,OAAO,CAAC,GAAG,CAAC,0BAA0B,EAAE,SAAS,CAAC,CAAC;AACrD,CAAC;AAED;AACA;SACgB,OAAO,CAAC,MAAM,EAAE,IAAI,EAAE,GAAI,EAAE,QAAS,EAAE,QAAS;;IAE9D,MAAM,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;;IAEtC,IAAI,CAAC,OAAO;QAAE,OAAO;IACrB,MAAM,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;;IAE5B,MAAM,GAAG,GAAG,CAAC,SAAS;QACpB,IAAI,SAAS,EAAE;YACb,SAAS,CAAC,OAAO,CAAC,CAAC,MAAM;gBACvB,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;aACvB,CAAC,CAAC;SACJ;KACF,CAAC;;IAEF,IAAI,GAAG,KAAK,QAAQ,IAAI,OAAO,CAAC,MAAM,CAAC,EAAE;;;;;QAKvC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG;YACvB,IAAI,GAAG,KAAK,QAAQ,IAAI,GAAG,IAAI,QAAQ,EAAE;gBACvC,GAAG,CAAC,GAAG,CAAC,CAAC;aACV;SACF,CAAC,CAAC;KACJ;SAAM;;QAEL,IAAI,GAAG,KAAK,SAAS,EAAE;;YAErB,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;SACvB;QACD,QAAQ,IAAI;;YAEV;gBACE,IAAI,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE;;oBAExC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;iBAC5B;SACJ;KACF;;IAED,SAAS,CAAC,OAAO,CAAC,CAAC,MAAW;QAC5B,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE;;YAE5B,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC;SAC5B;aAAM;YACL,MAAM,EAAE,CAAC;SACV;KACF,CAAC,CAAC;;AAEL;;ACnIA;AACA,SAAS,YAAY,CAAC,UAAU,GAAG,KAAK,EAAE,OAAO,GAAG,KAAK;IACvD,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ;QACvC,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,QAAQ,CAAC,CAAC;;QAE/C,IAAI,CAAC,UAAU,EAAE;;YAEf,KAAK,CAAC,MAAM,mBAAoB,GAAG,CAAC,CAAC;SACtC;;QAED,IAAI,OAAO,EAAE;YACX,OAAO,GAAG,CAAC;SACZ;;QAED,IAAI,QAAQ,CAAC,GAAG,CAAC,EAAE;YACjB,OAAO,UAAU,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;SAClD;QACD,OAAO,GAAG,CAAC;KACZ,CAAC;AACJ,CAAC;AAED;AACA;AACA,MAAM,GAAG,iBAAiB,YAAY,EAAE,CAAC;AACzC,MAAM,UAAU,iBAAiB,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;AAC3D,MAAM,WAAW,iBAAiB,YAAY,CAAC,IAAI,CAAC,CAAC;AACrD,MAAM,kBAAkB,iBAAiB,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAElE;AACA,SAAS,YAAY,CAAC,OAAO,GAAG,KAAK;IACnC,OAAO,SAAS,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ;;QAE9C,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;;;;QAI7B,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,YAAY,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;QAEtG,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzD,IAAI,CAAC,MAAM,EAAE;;YAEX,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,GAAG,CAAC,CAAC;;YAEtC,OAAO,CAAC,MAAM,mBAAsB,GAAG,EAAE,KAAK,CAAC,CAAC;SACjD;aAAM;;;YAGL,IAAI,UAAU,CAAC,KAAK,EAAE,QAAQ,CAAC,EAAE;gBAC/B,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;gBAC9B,OAAO,CAAC,MAAM,mBAAsB,GAAG,EAAE,KAAe,CAAC,CAAC;aAC3D;SACF;QACD,OAAO,MAAM,CAAC;KACf,CAAC;AACJ,CAAC;AACD,MAAM,GAAG,iBAAiB,YAAY,EAAE,CAAC;AACzC,MAAM,UAAU,iBAAiB,YAAY,CAAC,IAAI,CAAC,CAAC;AACpD;AACO,MAAM,eAAe,GAAG;IAC7B,GAAG;IACH,GAAG;CACJ,CAAC;AACF;AACO,MAAM,uBAAuB,GAAG;IACrC,GAAG,EAAE,UAAU;IACf,GAAG,EAAE,UAAU;CAChB,CAAC;AACF;AACO,MAAM,gBAAgB,GAAG;IAC9B,GAAG,EAAE,WAAW;IAChB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK;QACtB,OAAO,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;KAChC;CACF,CAAC;AACF;AACO,MAAM,sBAAsB,GAAG;IACpC,GAAG,EAAE,kBAAkB;IACvB,GAAG,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,KAAK;QACtB,OAAO,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;KAC/B;CACF;;SClFe,OAAO,CAAC,MAAM;IAC5B,OAAO,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;AAC1D,CAAC;SACe,eAAe,CAAC,MAAM;IACpC,OAAO,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;AAClE,CAAC;SACe,QAAQ,CAAC,MAAM;IAC7B,OAAO,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,gBAAgB,CAAC,CAAC;AAC1D,CAAC;SACe,cAAc,CAAC,MAAM;IACnC,OAAO,gBAAgB,CAAC,MAAM,EAAE,IAAI,EAAE,sBAAsB,CAAC,CAAC;AAChE,CAAC;AAED;AACA;AACA,MAAM,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;AACjC,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;AAClC;AACA,SAAS,gBAAgB,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY;IACxD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;QACrB,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAA;QACxB,OAAO,MAAM,CAAC;KACf;IACD,OAAO,CAAC,GAAG,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;;IAErC,MAAM,QAAQ,GAAG,UAAU,GAAG,WAAW,GAAG,UAAU,CAAC;IACvD,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;;IAErC,IAAI,OAAO,EAAE;QACX,OAAO,OAAO,CAAC;KAChB;;IAED,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAE,YAAY,CAAC,CAAC;IAC9C,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC5B,OAAO,KAAK,CAAC;AACf;;SCjCgB,GAAG,CAAC,MAAM;IACxB,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC;AAC3B,CAAC;AAKD;AACA,MAAM,OAAO;IAGQ;IAAiB;IAF7B,SAAS,GAAG,IAAI,CAAC;IACjB,MAAM,CAAC;IACd,YAAmB,QAAQ,EAAS,OAAO;QAAxB,aAAQ,GAAR,QAAQ,CAAA;QAAS,YAAO,GAAP,OAAO,CAAA;QACzC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;KACxB;;IAED,IAAI,KAAK;QACP,KAAK,CAAC,IAAI,mBAAoB,OAAO,CAAC,CAAC;QACvC,OAAO,IAAI,CAAC,MAAM,CAAC;KACpB;IACD,IAAI,KAAK,CAAC,QAAQ;;QAEhB,IAAI,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,EAAE;YACrC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC;YACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;YAC5B,OAAO,CAAC,IAAI,mBAAsB,OAAO,EAAE,QAAQ,CAAC,CAAC;SACtD;KACF;CACF;AACD;;;;;;AAMA,SAAS,SAAS,CAAC,QAAQ,EAAE,OAAO,GAAG,KAAK;;IAE1C,OAAO,IAAI,OAAO,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AACxC,CAAC;AACD;;;;;;SAMgB,KAAK,CAAC,MAAM,EAAE,GAAG;IAC/B,OAAO,IAAI,aAAa,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;AACxC,CAAC;AACD;;;;;AAKA,MAAM,aAAa;IAEE;IAAe;IAD3B,SAAS,GAAG,IAAI,CAAC;IACxB,YAAmB,MAAM,EAAS,GAAG;QAAlB,WAAM,GAAN,MAAM,CAAA;QAAS,QAAG,GAAH,GAAG,CAAA;KAAI;IACzC,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KAC9B;IACD,IAAI,KAAK,CAAC,QAAQ;QAChB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;KAClC;CACF;AACD;;;;;SAKgB,MAAM,CAAC,MAAM;;;IAG3B,IAAI,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;IAC1D,KAAK,IAAI,GAAG,IAAI,MAAM,EAAE;;QAEtB,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;KAC/B;IACD,OAAO,GAAG,CAAC;AACb;;AC9EA;SACgB,QAAQ,CAAC,eAAe;;;IAGtC,IAAI,MAAM,CAAC;IACX,IAAI,MAAM,CAAC;IACX,IAAI,UAAU,CAAC,eAAe,CAAC,EAAE;QAC/B,MAAM,GAAG,eAAe,CAAC;QACzB,MAAM,GAAG;YACP,OAAO,CAAC,IAAI,CAAC,iCAAiC,CAAC,CAAC;SACjD,CAAC;KACH;SAAM;;;QAGL,MAAM,GAAG,eAAe,CAAC,GAAG,CAAC;QAC7B,MAAM,GAAG,eAAe,CAAC,GAAG,CAAC;KAC9B;IACD,OAAO,IAAI,eAAe,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAC7C,CAAC;AAED,MAAM,eAAe;IAIQ;IAHpB,MAAM,GAAG,IAAI,CAAC;IACd,MAAM,CAAC;IACP,MAAM,CAAC;IACd,YAAY,MAAM,EAAS,MAAM;QAAN,WAAM,GAAN,MAAM,CAAA;;;QAG/B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,EAAE;YAC3B,IAAI,EAAE,IAAI;YACV,SAAS,EAAE;;gBAET,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;oBAChB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;iBACpB;aACF;SACF,CAAC,CAAC;KACJ;;IAED,IAAI,KAAK;;;QAGP,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,CAAC,GAAG,CAAC,8BAA8B,CAAC,CAAC;YAC5C,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;YACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;SAC7B;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;KACpB;IACD,IAAI,KAAK,CAAC,QAAQ;QAChB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;KACvB;;;;;;;;;;;;;"}